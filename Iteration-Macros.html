<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This manual documents For (version 1.2).

Copyright (C) 2022 Wing Hei Chan

This document is free documentation: you can redistribute it and/or
modify it under the terms of the GNU General Public License as published
by the Free Software Foundation, either version 3 of the License, or (at
your option) any later version.

This document is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License along
with this document.  If not, see https://www.gnu.org/licenses/. -->
<title>Iteration Macros (For)</title>

<meta name="description" content="Iteration Macros (For)">
<meta name="keywords" content="Iteration Macros (For)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Iteration-Forms.html" rel="up" title="Iteration Forms">
<link href="Special_002dClause-Operators.html" rel="next" title="Special-Clause Operators">
<style type="text/css">
@import url("https://www.gnu.org/software/emacs/manual.css");
cite { font-style: italic; }
</style>

</head>

<body lang="en">
<div class="section" id="Iteration-Macros">
<div class="header">
<p>
Next: <a href="Special_002dClause-Operators.html" accesskey="n" rel="next">Special-Clause Operators</a>, Up: <a href="Iteration-Forms.html" accesskey="u" rel="up">Iteration Forms</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Iteration-Macros-1"></span><h3 class="section">4.1 Iteration Macros</h3>
<p>Iteration macros are global macros acting as the entry points of this
package.
</p>
<dl class="def">
<dt id="index-for_002dfold"><span class="category">Macro: </span><span><strong>for-fold</strong> <em>([binding&hellip;] [(<code>:result</code> expression&hellip;)]) ([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dfold' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the fundamental building block of other
iteration macros.  <var>body</var>s are first transformed according to the
following rules and appended to <var>for-clause</var>s preserving their
order:
</p>
<ul>
<li> Each form except the last one is transformed to a <code>:do</code> clause
unless it is already a special clause;

</li><li> The last form is treated as a multiple-value form as is.
</li></ul>

<p><var>for-clause</var>s are then processed in order.  Multiple adjacent
iteration clauses are treated as a group, and special clauses serve to
separate the groups of iteration clauses.  A group of iteration clauses
expands to a <code>while</code> loop wrapping the body expanded so far, and a
special clause expands according to its idiosyncratic rules, presumably
wrapping the body expanded so far.  A group of iteration clauses or a
special clause to the left of another group of iteration clauses or
special clause nests the latter.  The last form is a multiple-value form
that produces as many values as there are <var>binding</var>s.  It is an
error for the multiple-value form to produce not as many values as there
are <var>binding</var>s.
</p>
<p>After <var>for-clause</var>s are processed, <var>expression</var>s are appended to
the body, and <var>binding</var>s are bound by a <code>let</code> form wrapping the
body.  Given that <var>binding</var> has either the form
<code>(<var>identifier</var> [<var>expression</var>])</code> or
<var>identifier</var>, <var>expression</var> defaults to <code>nil</code> when there is
no <var>identifier</var>, <var>identifier</var> when there is one, <code>(cons
<var>identifier</var>&hellip;)</code> when there are two, and <code>(list
<var>identifier</var>&hellip;)</code> when there are three or more.
</p>
<p>An iteration clause has the form <code>(<var>pattern</var>
<var>sequence-form</var>)</code> where <var>pattern</var> is a <code>pcase</code> pattern and
<var>sequence-form</var> is either <code>(<var>head</var>
[<var>subform</var>&hellip;])</code> or <var>datum</var>.  Alternatively, it
has the form <code>(<var>sequence-form</var>)</code>, which is first transformed to
the former with a generated identifier as <var>pattern</var>.  It is then
iteratively expanded as follows:
</p>
<ul>
<li> If the sole <var>subform</var> is a <code>:do-in</code> form, terminate the
expansion;

</li><li> Else, if <var>datum</var> is a recognized literal object, expand to
<code>(<var>pattern</var> (<var>head</var> <var>datum</var>))</code> where <var>head</var> is the
corresponding sequence constructor;

</li><li> Else, if <var>head</var> is an alias of <var>base</var>, expand to
<code>(<var>pattern</var> (<var>base</var> [<var>subform</var>&hellip;]))</code>;

</li><li> Else, if <var>head</var> has an associated expander, call it with the
iteration clause as the sole argument;

</li><li> Else, expand to <code>(<var>pattern</var> (for-in-iterator (for-generator
<var>datum</var>)))</code>.
</li></ul>

<p>For each <var>identifier</var> and each <var>value</var> produced by the
multiple-value form, <var>identifier</var> is first bound to the value of
<var>expression</var> or <code>nil</code> when there is no <var>expression</var> and
later updated to <var>value</var> after each iteration.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dfold_002a"><span class="category">Macro: </span><span><strong>for-fold*</strong> <em>([binding&hellip;] [(<code>:result</code> expression&hellip;)]) ([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dfold_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-iteration-form"></span>
<p>This iteration macro is the <em>implicitly nesting</em> version of
<code>for-fold</code>, such that every iteration clause is a group in its own.
This is achieved by separating each pair of adjacent iteration clauses
with a vacuous special clause such as <code>(:do)</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002ddo"><span class="category">Macro: </span><span><strong>for-do</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002ddo' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro performs side effects and produces <code>nil</code> as
the value.  It is equivalent to the following form:
</p>
<div class="example">
<pre class="example">(for-fold ()
    ([<var>for-clause</var>&hellip;])
  [<var>body</var>&hellip;]
  (:values))
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-for_002ddo_002a"><span class="category">Macro: </span><span><strong>for-do*</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002ddo_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of <code>for-do</code>.
</p></dd></dl>

<p>Below, <var>for-clause*</var>s are <var>for-clause</var>s including the
transformed <var>body</var>s but excluding the multiple-value form, and
<var>value*</var> is the multiple-value form where each tail form
<code>(:values <var>expression</var>)</code> is replaced by <var>expression</var>,
implying that it is an error for the multiple-value form to produce not
exactly one value.
</p>
<dl class="def">
<dt id="index-for_002dlist"><span class="category">Macro: </span><span><strong>for-list</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dlist' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-terminology-11"></span>
<p>This iteration macro accumulates the values into a
fresh<a id="DOCF12" href="#FOOT12"><sup>12</sup></a> list and returns
the list.  It is equivalent to the following form where <var>list</var> is a
generated identifier:
</p>
<div class="example">
<pre class="example">(for-fold ((<var>list</var> '())
           (:result (nreverse <var>list</var>)))
    ([<var>for-clause*</var>&hellip;]
     (cons <var>value*</var> <var>list</var>)))
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-for_002dlist_002a"><span class="category">Macro: </span><span><strong>for-list*</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dlist_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of
<code>for-list</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dlists"><span class="category">Macro: </span><span><strong>for-lists</strong> <em>([identifier&hellip;] [(<code>:result</code> expression&hellip;)]) ([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dlists' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro accumulates the values into fresh lists and
sequentially evaluates <var>expression</var>s with <var>identifier</var>s bound to
the lists.  It is like <code>for-fold</code>, except:
</p>
<ul>
<li> Each <var>identifier</var> is transformed to <code>(<var>identifier</var> '())</code> as
<var>binding</var>, and <var>expression</var>s are wrapped in a <code>let</code> form
with each <var>identifier</var> bound to <code>(nreverse <var>identifier</var>)</code>;

</li><li> For each <var>expression</var> in the tail forms of the multiple-value form
and each <var>identifier</var>, <var>expression</var> is transformed to
<code>(cons <var>expression</var> <var>identifier</var>)</code>.  It is an error for the
multiple-value form to produce not as many values as there are
<var>identifier</var>s.
</li></ul>

<p>The values of <var>identifier</var>s during the iteration are unspecified.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dlists_002a"><span class="category">Macro: </span><span><strong>for-lists*</strong> <em>([identifier&hellip;] [(<code>:result</code> expression&hellip;)]) ([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dlists_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of
<code>for-lists</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dvector"><span class="category">Macro: </span><span><strong>for-vector</strong> <em>([for-clause&hellip;]) [<code>:length</code> length [<code>:init</code> init]] [body&hellip;]</em><a href='#index-for_002dvector' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-terminology-12"></span>
<p>When neither <var>length</var> nor <var>init</var> is present, this iteration
macro is equivalent to the following form (see <a data-manual="elisp" href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Vector-Functions.html#Vector-Functions">(elisp)Vector
Functions</a>), such that it coerces<a id="DOCF13" href="#FOOT13"><sup>13</sup></a> the list returned by <code>for-list</code> to vector:
</p>
<div class="example">
<pre class="example">(vconcat (for-list ([<var>for-clause</var>&hellip;])
           [<var>body</var>&hellip;]))
</pre></div>

<p>Otherwise, this iteration macro accumulates the values into a fresh
vector of length <var>length</var> with each element being <var>init</var> where
<var>init</var> defaults to <code>0</code> when omitted.  In such case, it is
equivalent to the following form (see <a data-manual="elisp" href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Setting-Generalized-Variables.html#Setting-Generalized-Variables">(elisp)Setting Generalized
Variables</a>) where <var>vector</var> and <var>index</var> are generated
identifiers provided that <var>length</var> and <var>init</var> are evaluated
exactly once in the apparent evaluation order:
</p>
<div class="example">
<pre class="example">(if (zerop <var>length</var>)
    []
  (let ((<var>vector</var> (make-vector <var>length</var> <var>init</var>)))
    (for-fold ((<var>index</var> 0))
        ([<var>for-clause*</var>&hellip;]
         (:do (setf (aref <var>vector</var> <var>index</var>)
                    <var>value*</var>))
         (:let (<var>index</var> (1+ <var>index</var>)))
         (:break (= <var>index</var> <var>length</var>))
         <var>index</var>))
    <var>vector</var>))
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-for_002dvector_002a"><span class="category">Macro: </span><span><strong>for-vector*</strong> <em>([for-clause&hellip;]) [<code>:length</code> length [<code>:init</code> init]] [body&hellip;]</em><a href='#index-for_002dvector_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of
<code>for-vector</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dstring"><span class="category">Macro: </span><span><strong>for-string</strong> <em>([for-clause&hellip;]) [<code>:length</code> length [<code>:init</code> init [<code>:multibyte</code> multibyte]]] [body&hellip;]</em><a href='#index-for_002dstring' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-terminology-13"></span>
<p>When neither <var>length</var>, <var>init</var>, nor <var>multibyte</var> is present,
this iteration macro is equivalent to the following form
(see <a data-manual="elisp" href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Strings.html#Creating-Strings">(elisp)Creating Strings</a>), such that it coerces the list
returned by <code>for-list</code> to string:
</p>
<div class="example">
<pre class="example">(concat (for-list ([<var>for-clause</var>&hellip;])
          [<var>body</var>&hellip;]))
</pre></div>

<p>Otherwise, this iteration macro accumulates the values into a fresh
string of length <var>length</var> with each element being <var>init</var> where
<var>init</var> defaults to <code>?\0</code> (see <a data-manual="elisp" href="https://www.gnu.org/software/emacs/manual/html_node/elisp/General-Escape-Syntax.html#General-Escape-Syntax">(elisp)General Escape
Syntax</a>) when omitted.  The string is always a multibyte string
(see <a data-manual="elisp" href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Non_002dASCII-Characters.html#Non_002dASCII-Characters">(elisp)Non-ASCII Characters</a>) when <var>multibyte</var> is true.  In
such case, it is equivalent to the following form where <var>string</var> and
<var>index</var> are generated identifiers provided that <var>length</var>,
<var>init</var>, and <var>multibyte</var> are evaluated exactly once in the
apparent evaluation order:
</p>
<div class="example">
<pre class="example">(if (zerop <var>length</var>)
    (if <var>multibyte</var>
        (make-string 0 ?\0 'multibyte)
      &quot;&quot;)
  (let ((<var>string</var> (make-string <var>length</var> <var>init</var> <var>multibyte</var>)))
    (for-fold ((<var>index</var> 0))
        ([<var>for-clause*</var>&hellip;]
         (:do (setf (aref <var>string</var> <var>index</var>)
                    <var>value*</var>))
         (:let (<var>index</var> (1+ <var>index</var>)))
         (:break (= <var>index</var> <var>length</var>))
         <var>index</var>))
    <var>string</var>))
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-for_002dstring_002a"><span class="category">Macro: </span><span><strong>for-string*</strong> <em>([for-clause&hellip;]) [<code>:length</code> length [<code>:init</code> init [<code>:multibyte</code> multibyte]]] [body&hellip;]</em><a href='#index-for_002dstring_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of
<code>for-string</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dand"><span class="category">Macro: </span><span><strong>for-and</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dand' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro performs <code>and</code> (see <a data-manual="elisp" href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Combining-Conditions.html#Combining-Conditions">(elisp)Combining
Conditions</a>) on the values.  It is equivalent to the following
form where <var>value</var> is a generated identifier:
</p>
<div class="example">
<pre class="example">(for-fold ((<var>value</var> t))
    ([<var>for-clause*</var>&hellip;]
     (:let (<var>value</var> <var>value*</var>))
     (:final (not <var>value</var>))
     <var>value</var>))
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-for_002dand_002a"><span class="category">Macro: </span><span><strong>for-and*</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dand_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of
<code>for-and</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dor"><span class="category">Macro: </span><span><strong>for-or</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dor' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro performs <code>or</code> on the values.  It is equivalent
to the following form where <var>value</var> is a generated identifier:
</p>
<div class="example">
<pre class="example">(for-fold ((<var>value</var> nil))
    ([<var>for-clause*</var>&hellip;]
     (:let (<var>value</var> <var>value*</var>))
     (:final <var>value</var>)
     <var>value</var>))
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-for_002dor_002a"><span class="category">Macro: </span><span><strong>for-or*</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dor_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of <code>for-or</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dsum"><span class="category">Macro: </span><span><strong>for-sum</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dsum' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro accumulates the values into a sum.  It is
equivalent to the following form where <var>sum</var> is a generated
identifier:
</p>
<div class="example">
<pre class="example">(for-fold ((<var>sum</var> 0))
    ([<var>for-clause*</var>&hellip;]
     (+ <var>value*</var> <var>sum</var>)))
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-for_002dsum_002a"><span class="category">Macro: </span><span><strong>for-sum*</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dsum_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of
<code>for-sum</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dproduct"><span class="category">Macro: </span><span><strong>for-product</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dproduct' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro accumulates the values into a product.  It is
equivalent to the following form where <var>product</var> is a generated
identifier:
</p>
<div class="example">
<pre class="example">(for-fold ((<var>product</var> 0))
    ([<var>for-clause*</var>&hellip;]
     (* <var>value*</var> <var>product</var>)))
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-for_002dproduct_002a"><span class="category">Macro: </span><span><strong>for-product*</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dproduct_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of
<code>for-product</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dfirst"><span class="category">Macro: </span><span><strong>for-first</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dfirst' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro returns the first value or <code>nil</code> if the
iteration never begins.  It is equivalent to the following form where
<var>value</var> is a generated identifier:
</p>
<div class="example">
<pre class="example">(for-fold ((<var>value</var> nil))
    ((:final)
     [<var>for-clause</var>&hellip;])
  [<var>body</var>&hellip;])
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-for_002dfirst_002a"><span class="category">Macro: </span><span><strong>for-first*</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dfirst_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of
<code>for-first</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dlast"><span class="category">Macro: </span><span><strong>for-last</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dlast' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro returns the last value or <code>nil</code> if the
iteration never begins.  It is equivalent to the following form where
<var>value</var> is a generated identifier:
</p>
<div class="example">
<pre class="example">(for-fold ((<var>value</var> nil))
    ([<var>for-clause</var>&hellip;])
  [<var>body</var>&hellip;])
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-for_002dlast_002a"><span class="category">Macro: </span><span><strong>for-last*</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dlast_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of
<code>for-last</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dmax"><span class="category">Macro: </span><span><strong>for-max</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dmax' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro performs <code>max</code> (see <a data-manual="elisp" href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Comparison-of-Numbers.html#Comparison-of-Numbers">(elisp)Comparison of
Numbers</a>) on the values.  It is equivalent to the following form
where <var>max</var> is a generated identifier:
</p>
<div class="example">
<pre class="example">(for-fold ((<var>max</var> -1.0e+INF))
    ([<var>for-clause*</var>&hellip;]
     (max <var>value*</var> <var>max</var>)))
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-for_002dmax_002a"><span class="category">Macro: </span><span><strong>for-max*</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dmax_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of
<code>for-max</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dmin"><span class="category">Macro: </span><span><strong>for-min</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dmin' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro performs <code>min</code> on the values.  It is
equivalent to the following form where <var>min</var> is a generated
identifier:
</p>
<div class="example">
<pre class="example">(for-fold ((<var>min</var> 1.0e+INF))
    ([<var>for-clause*</var>&hellip;]
     (min <var>value*</var> <var>min</var>)))
</pre></div>
</dd></dl>

</div>
<div class="footnote">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h5><a id="FOOT12" href="#DOCF12">(12)</a></h5>
<p>Following
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_f.htm">Common Lisp</a>, a <em>fresh</em> object is newly allocated.</p>
<h5><a id="FOOT13" href="#DOCF13">(13)</a></h5>
<p>Following
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm">Common Lisp</a>, <em>coerce</em> means to non-destructively convert an object
to another type.</p>
</div>
<hr>
<div class="header">
<p>
Next: <a href="Special_002dClause-Operators.html">Special-Clause Operators</a>, Up: <a href="Iteration-Forms.html">Iteration Forms</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
