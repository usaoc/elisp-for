<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This manual documents For (version 1.1).

Copyright (C) 2022 Wing Hei Chan

This document is free documentation: you can redistribute it and/or
modify it under the terms of the GNU General Public License as published
by the Free Software Foundation, either version 3 of the License, or (at
your option) any later version.

This document is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License along
with this document.  If not, see https://www.gnu.org/licenses/. -->
<title>Iteration Macros (For)</title>

<meta name="description" content="Iteration Macros (For)">
<meta name="keywords" content="Iteration Macros (For)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Iteration-Forms.html" rel="up" title="Iteration Forms">
<link href="Special_002dClause-Operators.html" rel="next" title="Special-Clause Operators">
<style type="text/css">
@import url("https://www.gnu.org/software/emacs/manual.css");
cite { font-style: italic; }
</style>

</head>

<body lang="en">
<div class="section" id="Iteration-Macros">
<div class="header">
<p>
Next: <a href="Special_002dClause-Operators.html" accesskey="n" rel="next">Special-Clause Operators</a>, Up: <a href="Iteration-Forms.html" accesskey="u" rel="up">Iteration Forms</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Iteration-Macros-1"></span><h3 class="section">5.1 Iteration Macros</h3>
<p>Iteration macros are global macros acting as the entry points of this
package.
</p>
<dl class="def">
<dt id="index-for_002dfold"><span class="category">Macro: </span><span><strong>for-fold</strong> <em>bindings ([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dfold' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the fundamental building block of other
iteration macros.  The form of <var>bindings</var> is the same as the
<var>varlist</var> subforms of <code>let</code> forms, that is, a <var>binding</var> in
<var>bindings</var> has either the form <code>(<var>identifier</var>
[<var>expression</var>])</code> or <var>identifier</var>, except that an
optional <code>(:result <var>expression</var>&hellip;)</code> form can appear as
the last form.  <var>body</var>s are first transformed according to the
following rules and appended to <var>for-clause</var>s preserving their
order:
</p>
<ul>
<li> Each form except the last one is transformed to a <code>:do</code> clause
unless it is already a special clause;

</li><li> The last form is treated as a multiple-value form as is.
</li></ul>

<p><var>for-clause</var>s are then processed in order.  Multiple adjacent
iteration clauses are treated as a group, and special clauses serve to
separate the groups of iteration clauses.  A group of iteration clauses
or a special clause to the left of another group of iteration clauses or
special clause nests the latter.  The last form is a multiple-value form
that produces as many values as there are <var>binding</var>s.  It is an
error for the multiple-value form to produce not as many values as there
are <var>binding</var>s.
</p>
<p>A group of iteration clauses expands to a <code>while</code> loop wrapping the
body expanded so far.  A special clause expands according to its
idiosyncratic rules, presumably wrapping the body expanded so far.
Finally, <var>binding</var>s are bound by a <code>let</code> form wrapping the body
expanded so far, and the <var>expression</var>s in the <code>:result</code> form
are appended.  When no <code>:result</code> form is present, the sole
expression defaults to <code>nil</code> when there is no <var>identifier</var>,
<var>identifier</var> when there is one, <code>(cons
<var>identifier</var>&hellip;)</code> when there are two, and <code>(list
<var>identifier</var>&hellip;)</code> when there are three or more.
</p>
<p>An iteration clause has the form <code>(<var>form</var> <var>sequence-form</var>)</code>
where the form of <var>form</var> is specified by the value of
<code>for-binder</code> and <var>sequence-form</var> is either <code>(<var>head</var>
[<var>subform</var>&hellip;])</code> or <var>datum</var>.  Alternatively, it
has the form <code>(<var>sequence-form</var>)</code>, which is first transformed to
the former with a generated identifier as <var>form</var>.  It is then
iteratively expanded as follows:
</p>
<ul>
<li> If the sole <var>subform</var> is a <code>:do-in</code> form, terminate the
expansion;

</li><li> Else, if <var>datum</var> is a recognized literal object, expand to
<code>(<var>form</var> (<var>head</var> <var>datum</var>))</code> where <var>head</var> is the
corresponding sequence constructor;

</li><li> Else, if <var>head</var> is an alias of <var>base</var>, expand to
<code>(<var>form</var> (<var>base</var> [<var>subform</var>&hellip;]))</code>;

</li><li> Else, if <var>head</var> has an associated expander, call it with the
iteration clause as the sole argument;

</li><li> Else, expand to <code>(<var>form</var> (for-in-iterator (for-generator
<var>datum</var>)))</code>.
</li></ul>

<p>For each <var>identifier</var> and each <var>value</var> produced by the
multiple-value form, <var>identifier</var> is first bound to the value of
<var>expression</var> or <code>nil</code> when there is no <var>expression</var> and
later updated to <var>value</var> after each iteration.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dfold_002a"><span class="category">Macro: </span><span><strong>for-fold*</strong> <em>bindings ([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dfold_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-iteration-form"></span>

<p>This iteration macro is the <em>implicitly nesting</em> version of
<code>for-fold</code>, such that every iteration clause is a group in its own.
This is achieved by separating each pair of adjacent iteration clauses
with a vacuous special clause such as <code>(:do)</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002ddo"><span class="category">Macro: </span><span><strong>for-do</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002ddo' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro performs side effects and produces <code>nil</code> as
the value.  It is equivalent to the following <code>for-fold</code> form:
</p>
<div class="example">
<pre class="example">(for-fold ()
    ([<var>for-clause</var>&hellip;])
  [<var>body</var>&hellip;]
  (:values))
</pre></div>
</dd></dl>

<dl class="def">
<dt id="index-for_002ddo_002a"><span class="category">Macro: </span><span><strong>for-do*</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002ddo_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of <code>for-do</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dlist"><span class="category">Macro: </span><span><strong>for-list</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dlist' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-terminology-11"></span>

<p>This iteration macro accumulates the values into a
fresh<a id="DOCF12" href="#FOOT12"><sup>12</sup></a> list and returns
the list.  It is like <code>for-fold</code>, except:
</p>
<ul>
<li> <var>bindings</var> is <code>((<var>list</var> '()) (:result (nreverse
<var>list</var>)))</code> where <var>list</var> is a generated identifier;

</li><li> Each expression <var>expression</var> in the tail forms of the multiple-value
form is transformed to <code>(cons <var>expression</var> <var>list</var>)</code>.  It is
an error for the multiple-value form to produce not exactly one value.
</li></ul>
</dd></dl>

<dl class="def">
<dt id="index-for_002dlist_002a"><span class="category">Macro: </span><span><strong>for-list*</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dlist_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of
<code>for-list</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dlists"><span class="category">Macro: </span><span><strong>for-lists</strong> <em>bindings ([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dlists' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro accumulates the values into fresh lists and
sequentially evaluates the expressions in the <code>:result</code> form with
the identifiers in <var>bindings</var> bound to the lists.  It is like
<code>for-fold</code>, except:
</p>
<ul>
<li> <var>bindings</var> is a list of identifiers with an optional <code>:result</code>
form where each identifier is initially bound to <code>'()</code>;

</li><li> The expressions in the <code>:result</code> form, with the same default as
<code>for-fold</code>, are wrapped in a <code>let</code> form with each identifier
<var>identifier</var> in <var>bindings</var> bound to <code>(nreverse
<var>identifier</var>)</code>;

</li><li> For each expression <var>expression</var> in the tail forms of the
multiple-value form and each identifier <var>identifier</var> in
<var>bindings</var>, <var>expression</var> is transformed to <code>(cons
<var>expression</var> <var>identifier</var>)</code>.  It is an error for the
multiple-value form to produce not as many values as there are
identifiers in <var>bindings</var>.
</li></ul>

<p>The values of <var>identifier</var>s during the iteration are unspecified.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dlists_002a"><span class="category">Macro: </span><span><strong>for-lists*</strong> <em>bindings ([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dlists_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of
<code>for-lists</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dvector"><span class="category">Macro: </span><span><strong>for-vector</strong> <em>([for-clause&hellip;]) [<code>:length</code> length [<code>:init</code> init]] [body&hellip;]</em><a href='#index-for_002dvector' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-terminology-12"></span>

<p>When neither <var>length</var> nor <var>init</var> is present, this iteration
macro is equivalent to the following form (see <a data-manual="elisp" href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Vector-Functions.html#Vector-Functions">(elisp)Vector
Functions</a>), such that it coerces<a id="DOCF13" href="#FOOT13"><sup>13</sup></a> the list returned by <code>for-list</code> to vector:
</p>
<div class="example">
<pre class="example">(vconcat (for-list ([<var>for-clause</var>&hellip;])
           [<var>body</var>&hellip;]))
</pre></div>

<p>Otherwise, this iteration macro accumulates the values into a fresh
vector of length <var>length</var> with each element being <var>init</var> where
<var>init</var> defaults to <code>0</code> when omitted.  In such case, it is like
<code>for-fold</code>, except:
</p>
<ul>
<li> The iteration form is first transformed to the following form where
<var>vector</var> and <var>index</var> are generated identifiers provided that
<var>length</var> and <var>init</var> are evaluated exactly once in the apparent
evaluation order:

<div class="example">
<pre class="example">(if (zerop <var>length</var>)
    []
  (let ((<var>vector</var> (make-vector <var>length</var> <var>init</var>)))
    (let ((<var>index</var> 0))
      (for-do ([<var>for-clause</var>&hellip;])
        [<var>body</var>&hellip;]))
    <var>vector</var>))
</pre></div>

</li><li> Each expression <var>expression</var> in the tail forms of the multiple-value
form is transformed to <code>(setf (aref <var>vector</var> <var>index</var>)
<var>expression</var>)</code> (see <a data-manual="elisp" href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Setting-Generalized-Variables.html#Setting-Generalized-Variables">(elisp)Setting Generalized Variables</a>), and
the transformed multiple-value form <var>form</var> is inserted into the
<code>:do</code> clause <code>(:do <var>form</var> (cl-incf <var>index</var>))</code>
(see <a data-manual="cl" href="https://www.gnu.org/software/emacs/manual/html_node/cl/Modify-Macros.html#Modify-Macros">(cl)Modify Macros</a>).  It is an error for the multiple-value
form to produce not exactly one value;

</li><li> A <code>:break</code> clause <code>(:break (= <var>index</var> <var>length</var>))</code> is
inserted after the above-mentioned <code>:do</code> clause.
</li></ul>
</dd></dl>

<dl class="def">
<dt id="index-for_002dvector_002a"><span class="category">Macro: </span><span><strong>for-vector*</strong> <em>([for-clause&hellip;]) [<code>:length</code> length [<code>:init</code> init]] [body&hellip;]</em><a href='#index-for_002dvector_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of
<code>for-vector</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dstring"><span class="category">Macro: </span><span><strong>for-string</strong> <em>([for-clause&hellip;]) [<code>:length</code> length [<code>:init</code> init [<code>:multibyte</code> multibyte]]] [body&hellip;]</em><a href='#index-for_002dstring' class='copiable-anchor'> &para;</a></span></dt>
<dd><span id="index-terminology-13"></span>

<p>When neither <var>length</var>, <var>init</var>, nor <var>multibyte</var> is present,
this iteration macro is equivalent to the following form
(see <a data-manual="elisp" href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Strings.html#Creating-Strings">(elisp)Creating Strings</a>), such that it coerces the list
returned by <code>for-list</code> to string:
</p>
<div class="example">
<pre class="example">(concat (for-list ([<var>for-clause</var>&hellip;])
          [<var>body</var>&hellip;]))
</pre></div>

<p>Otherwise, this iteration macro accumulates the values into a fresh
string of length <var>length</var> with each element being <var>init</var> where
<var>init</var> defaults to <code>?\0</code> (see <a data-manual="elisp" href="https://www.gnu.org/software/emacs/manual/html_node/elisp/General-Escape-Syntax.html#General-Escape-Syntax">(elisp)General Escape
Syntax</a>) when omitted.  The string is always a multibyte string
(see <a data-manual="elisp" href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Non_002dASCII-Characters.html#Non_002dASCII-Characters">(elisp)Non-ASCII Characters</a>) when <var>multibyte</var> is true
where <var>multibyte</var> defaults to <code>nil</code> when omitted.  In such
case, it is like <code>for-fold</code>, except:
</p>
<ul>
<li> The iteration form is first transformed to the following form where
<var>string</var> and <var>index</var> are generated identifiers provided that
<var>length</var>, <var>init</var>, and <var>multibyte</var> are evaluated exactly once
in the apparent evaluation order:

<div class="example">
<pre class="example">(if (zerop <var>length</var>)
    (if <var>multibyte</var>
        (make-string 0 ?\0 'multibyte)
      &quot;&quot;)
  (let ((<var>string</var> (make-string <var>length</var> <var>init</var> <var>multibyte</var>)))
    (let ((<var>index</var> 0))
      (for-do ([<var>for-clause</var>&hellip;])
        [<var>body</var>&hellip;]))
    <var>string</var>))
</pre></div>

</li><li> Each expression <var>expression</var> in the tail forms of the multiple-value
form is transformed to <code>(setf (aref <var>string</var> <var>index</var>)
<var>expression</var>)</code>, and the transformed multiple-value form <var>form</var>
is inserted into the <code>:do</code> clause <code>(:do <var>form</var> (cl-incf
<var>index</var>))</code> .  It is an error for the multiple-value form to produce
not exactly one value;

</li><li> A <code>:break</code> clause <code>(:break (= <var>index</var> <var>length</var>))</code> is
inserted after the above-mentioned <code>:do</code> clause.
</li></ul>
</dd></dl>

<dl class="def">
<dt id="index-for_002dstring_002a"><span class="category">Macro: </span><span><strong>for-string*</strong> <em>([for-clause&hellip;]) [<code>:length</code> length [<code>:init</code> init [<code>:multibyte</code> multibyte]]] [body&hellip;]</em><a href='#index-for_002dstring_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of
<code>for-string</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dand"><span class="category">Macro: </span><span><strong>for-and</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dand' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro performs <code>and</code> on the values.  It is like
<code>for-fold</code>, except:
</p>
<ul>
<li> The iteration form is first transformed to the following form where
<var>value</var> is a generated identifier:

<div class="example">
<pre class="example">(let ((<var>value</var> t))
  (for-do ([<var>for-clause</var>&hellip;])
    [<var>body</var>&hellip;])
  <var>value</var>)
</pre></div>

</li><li> Each expression <var>expression</var> in the tail forms of the multiple-value
form is transformed to <code>(setq <var>value</var> <var>expression</var>)</code>, and
the multiple-value form is transformed to a <code>:do</code> clause.  It is an
error for the multiple-value form to produce not exactly one value;

</li><li> A <code>:break</code> clause <code>(:break (not <var>value</var>))</code> is inserted
after the above-mentioned <code>:do</code> clause.
</li></ul>
</dd></dl>

<dl class="def">
<dt id="index-for_002dand_002a"><span class="category">Macro: </span><span><strong>for-and*</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dand_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of
<code>for-and</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dor"><span class="category">Macro: </span><span><strong>for-or</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dor' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro performs <code>or</code> on the values.  It is like
<code>for-fold</code>, except:
</p>
<ul>
<li> The iteration form is first transformed to the following form where
<var>value</var> is a generated identifier:

<div class="example">
<pre class="example">(let ((<var>value</var> nil))
  (for-do ([<var>for-clause</var>&hellip;])
    [<var>body</var>&hellip;])
  <var>value</var>)
</pre></div>

</li><li> Each expression <var>expression</var> in the tail forms of the multiple-value
form is transformed to <code>(setq <var>value</var> <var>expression</var>)</code>, and
the multiple-value form is transformed to a <code>:do</code> clause.  It is an
error for the multiple-value form to produce not exactly one value;

</li><li> A <code>:break</code> clause <code>(:break <var>value</var>)</code> is inserted after the
above-mentioned <code>:do</code> clause.
</li></ul>
</dd></dl>

<dl class="def">
<dt id="index-for_002dor_002a"><span class="category">Macro: </span><span><strong>for-or*</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dor_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of <code>for-or</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dsum"><span class="category">Macro: </span><span><strong>for-sum</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dsum' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro accumulates the values into a sum.  It is like
<code>for-fold</code>, except:
</p>
<ul>
<li> <var>bindings</var> is <code>((<var>sum</var> 0))</code> where <var>sum</var> is a generated
identifier;

</li><li> Each expression <var>expression</var> in the tail forms of the multiple-value
form is transformed to <code>(+ <var>expression</var> <var>sum</var>)</code>.  It is an
error for the multiple-value form to produce not exactly one value.
</li></ul>
</dd></dl>

<dl class="def">
<dt id="index-for_002dsum_002a"><span class="category">Macro: </span><span><strong>for-sum*</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dsum_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of
<code>for-sum</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dproduct"><span class="category">Macro: </span><span><strong>for-product</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dproduct' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro accumulates the values into a product.  It is like
<code>for-fold</code>, except:
</p>
<ul>
<li> <var>bindings</var> is <code>((<var>product</var> 1))</code> where <var>product</var> is a
generated identifier;

</li><li> Each expression <var>expression</var> in the tail forms of the multiple-value
form is transformed to <code>(* <var>expression</var> <var>product</var>)</code>.  It is
an error for the multiple-value form to produce not exactly one value.
</li></ul>
</dd></dl>

<dl class="def">
<dt id="index-for_002dproduct_002a"><span class="category">Macro: </span><span><strong>for-product*</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dproduct_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of
<code>for-product</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dfirst"><span class="category">Macro: </span><span><strong>for-first</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dfirst' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro returns the first value or <code>nil</code> if the
iteration never begins.  It is like <code>for-fold</code>, except:
</p>
<ul>
<li> <var>bindings</var> is <code>((<var>value</var> nil))</code> where <var>value</var> is a
generated identifier;

</li><li> A <code>:final</code> clause <code>(:final)</code> is inserted before the
multiple-value form, so that the iteration is immediately terminated
after the first iteration.
</li></ul>
</dd></dl>

<dl class="def">
<dt id="index-for_002dfirst_002a"><span class="category">Macro: </span><span><strong>for-first*</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dfirst_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of
<code>for-first</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dlast"><span class="category">Macro: </span><span><strong>for-last</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dlast' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro returns the last value or <code>nil</code> if the
iteration never begins.  It is like <code>for-fold</code>, except:
</p>
<ul>
<li> <var>bindings</var> is <code>((<var>value</var> nil))</code> where <var>value</var> is a
generated identifier.
</li></ul>
</dd></dl>

<dl class="def">
<dt id="index-for_002dlast_002a"><span class="category">Macro: </span><span><strong>for-last*</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dlast_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of
<code>for-last</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dmax"><span class="category">Macro: </span><span><strong>for-max</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dmax' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro performs <code>max</code> (see <a data-manual="elisp" href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Comparison-of-Numbers.html#Comparison-of-Numbers">(elisp)Comparison of
Numbers</a>) on the values.  It is like <code>for-fold</code>, except:
</p>
<ul>
<li> <var>bindings</var> is <code>((<var>max</var> -1.0e+INF))</code> (see <a data-manual="elisp" href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Float-Basics.html#Float-Basics">(elisp)Float
Basics</a>) where <var>max</var> is a generated identifier;

</li><li> Each expression <var>expression</var> in the tail forms of the multiple-value
form is transformed to <code>(max <var>expression</var> <var>max</var>)</code>.  It is
an error for the multiple-value form to produce not exactly one value.
</li></ul>
</dd></dl>

<dl class="def">
<dt id="index-for_002dmax_002a"><span class="category">Macro: </span><span><strong>for-max*</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dmax_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of
<code>for-max</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-for_002dmin"><span class="category">Macro: </span><span><strong>for-min</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dmin' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro performs <code>min</code> on the values.  It is like
<code>for-fold</code>, except:
</p>
<ul>
<li> <var>bindings</var> is <code>((<var>min</var> 1.0e+INF))</code> where <var>min</var> is a
generated identifier;

</li><li> Each expression <var>expression</var> in the tail forms of the multiple-value
form is transformed to <code>(min <var>expression</var> <var>min</var>)</code>.  It is
an error for the multiple-value form to produce not exactly one value.
</li></ul>
</dd></dl>

<dl class="def">
<dt id="index-for_002dmin_002a"><span class="category">Macro: </span><span><strong>for-min*</strong> <em>([for-clause&hellip;]) [body&hellip;]</em><a href='#index-for_002dmin_002a' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This iteration macro is the implicitly nesting version of
<code>for-min</code>.
</p></dd></dl>

</div>
<div class="footnote">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h5><a id="FOOT12" href="#DOCF12">(12)</a></h5>
<p>Following
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_f.htm">Common Lisp</a>, a <em>fresh</em> object is newly allocated.</p>
<h5><a id="FOOT13" href="#DOCF13">(13)</a></h5>
<p>Following
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm">Common Lisp</a>, <em>coerce</em> means to non-destructively convert an object
to another type.</p>
</div>
<hr>
<div class="header">
<p>
Next: <a href="Special_002dClause-Operators.html">Special-Clause Operators</a>, Up: <a href="Iteration-Forms.html">Iteration Forms</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
